<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="getting_started.html">Getting Started</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRules.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Documentation-1" href="#API-Documentation-1">API Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.AbstractRule" href="#ChainRulesCore.AbstractRule"><code>ChainRulesCore.AbstractRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Subtypes of <code>AbstractRule</code> are types which represent the primitive derivative propagation &quot;rules&quot; that can be composed to implement forward- and reverse-mode automatic differentiation.</p><p>More specifically, a <code>rule::AbstractRule</code> is a callable Julia object generally obtained via calling <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a> or <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>. Such rules accept differential values as input, evaluate the chain rule using internally stored/ computed partial derivatives to produce a single differential value, then return that calculated differential value.</p><p>For example:</p><pre><code class="language-julia-repl">julia&gt; using ChainRulesCore: frule, rrule, AbstractRule

julia&gt; x, y = rand(2);

julia&gt; h, dh = frule(hypot, x, y);

julia&gt; h == hypot(x, y)
true

julia&gt; isa(dh, AbstractRule)
true

julia&gt; Δx, Δy = rand(2);

julia&gt; dh(Δx, Δy) == ((y / h) * Δx + (x / h) * Δy)
true

julia&gt; h, (dx, dy) = rrule(hypot, x, y);

julia&gt; h == hypot(x, y)
true

julia&gt; isa(dx, AbstractRule) &amp;&amp; isa(dy, AbstractRule)
true

julia&gt; Δh = rand();

julia&gt; dx(Δh) == (y / h) * Δh
true

julia&gt; dy(Δh) == (x / h) * Δh
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.Rule"><code>Rule</code></a>, <a href="api.html#ChainRulesCore.DNERule"><code>DNERule</code></a>, <a href="api.html#ChainRulesCore.WirtingerRule"><code>WirtingerRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Casted" href="#ChainRulesCore.Casted"><code>ChainRulesCore.Casted</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.DNE" href="#ChainRulesCore.DNE"><code>ChainRulesCore.DNE</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.DNERule" href="#ChainRulesCore.DNERule"><code>ChainRulesCore.DNERule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DNERule(args...)</code></pre><p>Construct a <code>DNERule</code> object, which is an <code>AbstractRule</code> that signifies that the current function is not differentiable with respect to a particular parameter. <strong>DNE</strong> is an abbreviation for Does Not Exist.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.One" href="#ChainRulesCore.One"><code>ChainRulesCore.One</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Rule" href="#ChainRulesCore.Rule"><code>ChainRulesCore.Rule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Rule(propation_function[, updating_function])</code></pre><p>Return a <code>Rule</code> that wraps the given <code>propation_function</code>. It is assumed that <code>propation_function</code> is a callable object whose arguments are differential values, and whose output is a single differential value calculated by applying internally stored/computed partial derivatives to the input differential values.</p><p>If an updating function is provided, it is assumed to have the signature <code>u(Δ, xs...)</code> and to store the result of the propagation function applied to the arguments <code>xs</code> into <code>Δ</code> in-place, returning <code>Δ</code>.</p><p>For example:</p><pre><code class="language-none">frule(::typeof(*), x, y) = x * y, Rule((Δx, Δy) -&gt; Δx * y + x * Δy)

rrule(::typeof(*), x, y) = x * y, (Rule(ΔΩ -&gt; ΔΩ * y&#39;), Rule(ΔΩ -&gt; x&#39; * ΔΩ))</code></pre><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate</code></a>, <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate!</code></a>, <a href="api.html#ChainRulesCore.store!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>store!</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Thunk" href="#ChainRulesCore.Thunk"><code>ChainRulesCore.Thunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Wirtinger" href="#ChainRulesCore.Wirtinger"><code>ChainRulesCore.Wirtinger</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Wirtinger(primal::Union{Number,AbstractDifferential},
          conjugate::Union{Number,AbstractDifferential})</code></pre><p>Returns a <code>Wirtinger</code> instance representing the complex differential:</p><pre><code class="language-none">df = ∂f/∂z * dz + ∂f/∂z̄ * dz̄</code></pre><p>where <code>primal</code> corresponds to <code>∂f/∂z * dz</code> and <code>conjugate</code> corresponds to <code>∂f/∂z̄ * dz̄</code>.</p><p>The two fields of the returned instance can be accessed generically via the <a href="@ref"><code>wirtinger_primal</code></a> and <a href="@ref"><code>wirtinger_conjugate</code></a> methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Wirtinger-Tuple{Union{DNE, One, Zero, Real},Union{DNE, One, Zero, Real}}" href="#ChainRulesCore.Wirtinger-Tuple{Union{DNE, One, Zero, Real},Union{DNE, One, Zero, Real}}"><code>ChainRulesCore.Wirtinger</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Wirtinger(primal::Real, conjugate::Real)</code></pre><p>Return <code>add(primal, conjugate)</code>.</p><p>Actually implementing the Wirtinger calculus generally requires that the summed terms of the Wirtinger differential (<code>∂f/∂z * dz</code> and <code>∂f/∂z̄ * dz̄</code>) be stored individually. However, if both of these terms are real-valued, then downstream Wirtinger propagation mechanisms resolve to the same mechanisms as real-valued calculus, so that the terms&#39; sum can be eagerly computed and propagated without requiring a special <code>Wirtinger</code> representation</p><p>This method primarily exists as an optimization.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Zero" href="#ChainRulesCore.Zero"><code>ChainRulesCore.Zero</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.extern-Tuple{Any}" href="#ChainRulesCore.extern-Tuple{Any}"><code>ChainRulesCore.extern</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">extern(x)</code></pre><p>Return <code>x</code> converted to an appropriate non-<code>AbstractDifferential</code> type, for use with external packages that might not handle <code>AbstractDifferential</code> types.</p><p>Note that this function may return an alias (not necessarily a copy) to data wrapped by <code>x</code>, such that mutating <code>extern(x)</code> might mutate <code>x</code> itself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.frule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">frule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (rule_for_ΔΩ₁::AbstractRule, rule_for_ΔΩ₂::AbstractRule, ...))</code></pre><p>where each returned propagation rule <code>rule_for_ΔΩᵢ</code> can be invoked as</p><pre><code class="language-none">rule_for_ΔΩᵢ(Δx₁, Δx₂, ...)</code></pre><p>to yield <code>Ωᵢ</code>&#39;s corresponding differential <code>ΔΩᵢ</code>. To illustrate, if all involved values are real-valued scalars, this differential can be written as:</p><pre><code class="language-none">ΔΩᵢ = ∂Ωᵢ_∂x₁ * Δx₁ + ∂Ωᵢ_∂x₂ * Δx₂ + ...</code></pre><p>If no method matching <code>frule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sinx, dsin = frule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; dsin(1) == cos(x)
true</code></pre><p>unary input, binary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sincosx, (dsin, dcos) = frule(sincos, x);

julia&gt; sincosx == sincos(x)
true

julia&gt; dsin(1) == cos(x)
true

julia&gt; dcos(1) == -sin(x)
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.AbstractRule"><code>AbstractRule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rrule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (rule_for_Δx₁::AbstractRule, rule_for_Δx₂::AbstractRule, ...))</code></pre><p>where each returned propagation rule <code>rule_for_Δxᵢ</code> can be invoked as</p><pre><code class="language-none">rule_for_Δxᵢ(ΔΩ₁, ΔΩ₂, ...)</code></pre><p>to yield <code>xᵢ</code>&#39;s corresponding differential <code>Δxᵢ</code>. To illustrate, if all involved values are real-valued scalars, this differential can be written as:</p><pre><code class="language-none">Δxᵢ = ∂Ω₁_∂xᵢ * ΔΩ₁ + ∂Ω₂_∂xᵢ * ΔΩ₂ + ...</code></pre><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x = rand();

julia&gt; sinx, dx = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; dx(1) == cos(x)
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-julia-repl">julia&gt; x, y = rand(2);

julia&gt; hypotxy, (dx, dy) = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; dx(1) == (y / hypot(x, y))
true

julia&gt; dy(1) == (x / hypot(x, y))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.AbstractRule"><code>AbstractRule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.store!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}" href="#ChainRulesCore.store!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>ChainRulesCore.store!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">store!(Δ, rule::AbstractRule, args...)</code></pre><p>Compute <code>rule(args...)</code> and store the result in <code>Δ</code>, potentially avoiding intermediate temporary allocations that might be necessary for alternative approaches (e.g. <code>copyto!(Δ, extern(rule(args...)))</code>)</p><p>Note that this function internally calls <code>Base.Broadcast.materialize!(Δ, ...)</code>.</p><p>Like <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate</code></a> and <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate!</code></a>, this function is intended to be customizable for specific rules/input types.</p><p>See also: <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate</code></a>, <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate!</code></a>, <a href="api.html#ChainRulesCore.AbstractRule"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}" href="#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>ChainRulesCore.@scalar_rule</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for <code>frule</code> and <code>rrule</code>:</p><pre><code class="language-none">function ChainRulesCore.frule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (Rule((Δx₁, Δx₂, ...) -&gt; ∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
               Rule((Δx₁, Δx₂, ...) -&gt; ∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
               ...)
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (Rule((ΔΩ₁, ΔΩ₂, ...) -&gt; ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
               Rule((ΔΩ₁, ΔΩ₂, ...) -&gt; ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
               ...)
end</code></pre><p>If no type constraints in <code>f(x₁, x₂, ...)</code> within the call to <code>@scalar_rule</code> are provided, each parameter in the resulting <code>frule</code>/<code>rrule</code> definition is given a type constraint of <code>Number</code>. Constraints may also be explicitly be provided to override the <code>Number</code> constraint, e.g. <code>f(x₁::Complex, x₂)</code>, which will constrain <code>x₁</code> to <code>Complex</code> and <code>x₂</code> to <code>Number</code>.</p><p>Note that the result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be conveniently referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>Note that the <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>For examples, see ChainRulesCore&#39; <code>rules</code> directory.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.AbstractRule"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.AbstractDifferential" href="#ChainRulesCore.AbstractDifferential"><code>ChainRulesCore.AbstractDifferential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The subtypes of <code>AbstractDifferential</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>All subtypes of <code>AbstractDifferential</code> implement the following operations:</p><p><code>add(a, b)</code>: linearly combine differential <code>a</code> and differential <code>b</code></p><p><code>mul(a, b)</code>: multiply the differential <code>a</code> by the differential <code>b</code></p><p><code>Base.conj(x)</code>: complex conjugate of the differential <code>x</code></p><p><code>extern(x)</code>: convert <code>x</code> into an appropriate non-<code>AbstractDifferential</code> type for use outside of <code>ChainContext</code>.</p><p>Valid arguments to these operations are <code>T</code> where <code>T&lt;:AbstractDifferential</code>, or where <code>T</code> has proper <code>+</code> and <code>*</code> implementations.</p><p>Additionally, all subtypes of <code>AbstractDifferential</code> support <code>Base.iterate</code> and <code>Base.Broadcast.broadcastable(x)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.WirtingerRule" href="#ChainRulesCore.WirtingerRule"><code>ChainRulesCore.WirtingerRule</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>TODO</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.accumulate!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}" href="#ChainRulesCore.accumulate!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>ChainRulesCore.accumulate!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accumulate!(Δ, rule::AbstractRule, args...)</code></pre><p>Similar to <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate</code></a>, but compute <code>Δ + rule(args...)</code> in-place, storing the result in <code>Δ</code>.</p><p>Note that this function internally calls <code>Base.Broadcast.materialize!(Δ, ...)</code>.</p><p>See also: <a href="api.html#ChainRulesCore.accumulate-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate</code></a>, <a href="api.html#ChainRulesCore.store!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>store!</code></a>, <a href="api.html#ChainRulesCore.AbstractRule"><code>AbstractRule</code></a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.accumulate-Tuple{Any,AbstractRule,Vararg{Any,N} where N}" href="#ChainRulesCore.accumulate-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>ChainRulesCore.accumulate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accumulate(Δ, rule::AbstractRule, args...)</code></pre><p>Return <code>Δ + rule(args...)</code> evaluated in a manner that supports ChainRulesCore&#39; various <code>AbstractDifferential</code> types.</p><p>This method intended to be customizable for specific rules/input types. For example, here is pseudocode to overload <code>accumulate</code> w.r.t. a specific forward differentiation rule for a given function <code>f</code>:</p><pre><code class="language-none">df(x) = # forward differentiation primitive implementation

frule(::typeof(f), x) = (f(x), Rule(df))

accumulate(Δ, rule::Rule{typeof(df)}, x) = # customized `accumulate` implementation</code></pre><p>See also: <a href="api.html#ChainRulesCore.accumulate!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>accumulate!</code></a>, <a href="api.html#ChainRulesCore.store!-Tuple{Any,AbstractRule,Vararg{Any,N} where N}"><code>store!</code></a>, <a href="api.html#ChainRulesCore.AbstractRule"><code>AbstractRule</code></a></p></div></div></section><footer><hr/><a class="previous" href="getting_started.html"><span class="direction">Previous</span><span class="title">Getting Started</span></a></footer></article></body></html>
